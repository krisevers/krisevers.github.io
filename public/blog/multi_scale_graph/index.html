<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>Kris Evers</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    <!-- mathtex -->
    <link type="text/css" rel="stylesheet" href="/Temml-Local.css">
    <script defer src="/temml.min.js"></script>
    <script defer src="/render-mathtex.js"></script>
    <!-- /mathtex -->
    
  <style>
    .date {
      font-size: 0.9em;
      text-align: center;
    }
    .title h3{
      margin-top: 0;
    }

    figure {
        align-self: center;
        text-align: center;
    }
  </style>

  </head>
  <body id="body">

    <nav>
        <div class="nav-container">
            <a class="nav-brand" href="/">Kris Evers</a>
        </div>
        <div class="nav-container">
            <a class="nav-item" href="/">About</a>
            <a class="nav-item" href="/blog/">Posts</a>
            <a class="nav-item" href="/projects/">Projects</a>
            <a class="nav-item" href="/publications/">Publications</a>
            <a class="nav-item" href="/bookmarks/">Bookmarks</a>
            <div class="nav-item"></div>
        </div>
    </nav>

    <!--<card>
        <a class="card-header" href="$site.page('').link()">
            <h2 class="card-title">Hello</h2>
            <p class="card-subtitle">date</p>
        </a>

        <div class="card-body">
            <p class="card-excerpt">
                some short text introducing the article.
            </p>
        </div>
        <div class="card-actions">
            <span class="tag">zig</span>
            <span class="tag">systems biology</span>
        </div>
    </card>-->

    
  <span class="date">August 07, 2025</span>
  <h1>Representing Multi-Scale Systems using Directed Acyclic Graphs</h1>
  <div><p>Say you want to build a model of biological tissue (e.g. muscle or hearth tissue) using a set of cells which all have their own position variables. The straight forward way of modelling this is by placing all variables in a continuous array.</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">Position</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span> <span class="constant variable_builtin type variable_member variable">x</span> <span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable_member variable">y</span> <span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable_member variable">z</span> <span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
<span class="keyword">const</span> <span class="constant variable_builtin type variable">positions</span> <span class="operator">=</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">_</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">Position</span> <span class="operator">**</span> <span class="number">1000</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>The indices into this array are the handles to a cell in the model, assuming you don’t shuffle the order of the position data. The moment you want to subdivide a tissue into two or more specific specialized tissues you could just get slices into the array to obtain all positions belonging to one of the tissues:</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">muscle_tissue</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">positions</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="number">500</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>
<span class="keyword">const</span> <span class="constant variable_builtin type variable">heart_tissue</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">positions</span><span class="punctuation_bracket">[</span><span class="number">500</span><span class="operator">..</span><span class="number">1000</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>This approach to organizing your models works well if all your components operate at the same scale. Model components have a one-to-one relationship and the memory layout is cache-friendly in well suited for SIMD (Single Input, Multiple Data) optimization.</p><p>But what if there is no one-to-one relation between model components? Such a situation occurs when there are components at different scales which dependent on each other. For example, when computing the mean fiber orientation from the positions in <code>muscle_tissue</code>, or when global tissue stress influences individual cell behavior. Ofcourse you could just create a new variable which stores the global variables representing the fiber properties:</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">Fiber</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span> <span class="constant variable_builtin type variable_member variable">pos</span> <span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">Position</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable_member variable">orientation</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable_member variable">tension</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span> <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>but the moment you want to extend your model to include more muscle, diversify the tissue, or add even more scales at the top or bottom you run will end up creating a spagetti of dependencies between variables which quickly will become unmanagable. If you are not careful the indices become unstable handles to the data, and adding new components or scales requires extensive refactoring. Using a basic slicing method becomes unmanagable for any model with more than two layers of hierarchy. To prevent running into such problems we need a data structure which makes the hierarchical, multi-scale relationships explicit.</p><h2>Variables, Collections and Components</h2><p>Inspired by component system architectures I use integer handles to represent both variables (e.g. a position, a velocity, a membrane potential) and collections of variables (e.g. a cell, a membrane, a muscle) using unique integer based IDs. Using such handles, defining a model becomes a question of moving around such IDs and writing functionality to make it this an easy process. This way we separate the actual allocation of the model data from the model design. Scientists think in terms of cells, tissues, organs, and ecosystems - not of memory adresses and SIMD registers. Humans tend to model systems as they appear in nature, with clear physical boundaries and dynamics that depend only on local neighborhoods. However, computers excel at performing similar operations in bulk, especially when data is aligned for SIMD operations. Traditional approaches often sacrifice readability and extensibility for performance, forcing researchers to re-optimize their code whenever the model changes. By abstracting the model structure, researchers can focus on implementing the dynamics of individual systems while maintaining a flexible, human-readable way to define the model and its component relationships.</p><blockquote><p>The remainder of this post explores a possible implementation of such a component based system. Code blocks are written in the <code>zig</code> language, so don’t forget to <code>const std = @import(&quot;std&quot;);</code>. However, the concepts discussed are general and translates to any systems programming language.</p></blockquote><p>Generating unique IDs could be done with a simple pattern:</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">genID</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">S</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">var</span> <span class="constant variable_builtin type variable">uid</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">atomic</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">Value</span><span class="punctuation_bracket">(</span><span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">atomic</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">Value</span><span class="punctuation_bracket">(</span><span class="type_builtin">usize</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="number">0</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">S</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">uid</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">fetchAdd</span><span class="punctuation_bracket">(</span><span class="number">1</span><span class="punctuation_delimiter">,</span> <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">monotonic</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p><code>uid</code> increments atomically each time <code>genID()</code> is called ensuring unique IDs. Component specific information can then be kept using arrays of <code>enums</code>:</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">ComponentType</span> <span class="keyword_type">enum</span> <span class="punctuation_bracket">{</span>
    <span class="constant variable_builtin type variable">Inactive</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin type variable">Variable</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin type variable">Parameter</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin type variable">Collection</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>Now we have a way of creating model components by generating unique IDs.</p><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;create components&quot;</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation_delimiter">;</span> <span class="comment_documentation comment spell">// max number of components</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">components</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">_</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_bracket">{</span><span class="constant variable_builtin type variable">Componenttype</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Inactive</span><span class="punctuation_bracket">}</span> <span class="operator">**</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_delimiter">;</span>

    <span class="keyword">const</span> <span class="constant variable_builtin type variable">x</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">genID</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">y</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">genID</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">z</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">genID</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

    <span class="comment_documentation comment spell">// position</span>
    <span class="constant variable_builtin type variable">components</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">x</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">components</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">y</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">components</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">z</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_delimiter">;</span>

    <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">expect</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">x</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">expect</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">y</span> <span class="operator">==</span> <span class="number">1</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">expect</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">z</span> <span class="operator">==</span> <span class="number">2</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h2>The Multi-Scale Graph</h2><p>The second part of the data structure is a graph which handles relationships between components (i.e. IDs). To build such associations we need a container to store these relations, an adjacency matrix (<code>relations</code>). For convenience we store the components and relations in a <code>register</code>.</p><pre><code class="zig"><span class="keyword">const</span> <span class="constant variable_builtin type variable">Registry</span> <span class="operator">=</span> <span class="keyword_type">struct</span> <span class="punctuation_bracket">{</span>
    <span class="constant variable_builtin type variable_member variable">components</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable_member variable">relations</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="type_builtin">i32</span><span class="punctuation_delimiter">;</span>
    size<span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">;</span>
    capacity<span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">;</span>
    <span class="constant label type variable variable_builtin">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Allocator</span><span class="punctuation_delimiter">,</span>

    <span class="keyword">const</span> <span class="module constant variable_builtin type variable">Self</span> <span class="operator">=</span> <span class="function_builtin keyword_import">@This</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

    <span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">allocator</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Allocator</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">capacity</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="constant variable_builtin type variable">Self</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">const</span> <span class="constant variable_builtin type variable">components</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="function_builtin">@memset</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">components</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Inactive</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

        <span class="keyword">const</span> <span class="constant variable_builtin type variable">relations</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">relations</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="operator">*</span><span class="constant variable_builtin type variable">row</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
            <span class="constant variable_builtin type variable">row</span><span class="operator">.*</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">alloc</span><span class="punctuation_bracket">(</span><span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="function_builtin">@memset</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">row</span><span class="operator">.*</span><span class="punctuation_delimiter">,</span> <span class="number">0</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>

        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">Self</span><span class="punctuation_bracket">{</span>
            <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">components</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">components</span><span class="punctuation_delimiter">,</span>
            <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">relations</span>  <span class="operator">=</span> <span class="constant variable_builtin type variable">relations</span><span class="punctuation_delimiter">,</span>
            <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">size</span> <span class="operator">=</span> <span class="number">0</span><span class="punctuation_delimiter">,</span>
            <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">capacity</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">capacity</span><span class="punctuation_delimiter">,</span>
            <span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">,</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>

    <span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">has</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">Self</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">id</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">id</span> <span class="operator">&lt;</span> <span class="constant variable_builtin type variable">capacity</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="constant variable_builtin type variable">components</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">id</span><span class="punctuation_bracket">]</span> <span class="operator">!=</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Inactive</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>

    <span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">self</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">Self</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">ctype</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_bracket">)</span> <span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">const</span> <span class="constant variable_builtin type variable">id</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">genID</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">id</span> <span class="operator">&gt;=</span> <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">capacity</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="comment_documentation comment spell">// out of bounds</span>
        <span class="punctuation_bracket">}</span>
        <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">components</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">id</span><span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">ctype</span><span class="punctuation_delimiter">;</span>
        <span class="constant variable_builtin type variable">self</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">size</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation_delimiter">;</span>
        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">id</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>Each component can parent a <em>child</em> component as long as the <em>child</em> component is not already a parent of the <em>parent</em> or is down stream in the ancestry-tree of the <em>child</em>. This ensures the acyclic property and enforces the hierarchical nature of the graph. Multi-scale models often have a hierarchical tree like structure in which components at a higher abstraction level contain many similar components at a lower abstraction level. Therefore the directed acyclic graph structure is ideal to represent such an architecture. We can provide easy to use functionality to build up the graph by providing the <code>give</code> and <code>assemble</code> functions below.</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">give</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">reg</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">Registry</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">parent</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">child</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">copies</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
    <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="operator">!</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">has</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">parent</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
    <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="operator">!</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">has</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">child</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
    <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="operator">!</span><span class="constant variable_builtin type variable">hasParentInAncestry</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">parent</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">child</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
    <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">relations</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">parent</span><span class="punctuation_delimiter">,</span> child<span class="punctuation_bracket">]</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">copies</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">true</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

<span class="keyword_modifier">pub</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">reg</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">Registry</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">children</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">copies</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> <span class="operator">!</span><span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
    <span class="constant variable_builtin type variable">parent</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">Collection</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">children</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">child</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="operator">!</span><span class="constant variable_builtin type variable">give</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">parent</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">child</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">copies</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="keyword_return">return</span> <span class="keyword">error</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">InvalidConnection</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">parent</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>As one can see we need some additional functionality to get a valid registration of relations between components. By valid I mean we would not want circular relations between components. For example, we would like to make a <code>leaf</code> and a <code>root</code> children of a <code>tree</code>, but then it should be prevented to make <code>tree</code> a child of <code>root</code>.</p><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;give components&quot;</span> <span class="punctuation_bracket">{</span>

    <span class="constant variable_builtin type variable">Registry</span> reg<span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">capacity</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">tree</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">leaf</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="constant variable_builtin type variable">root</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

    <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">expect</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin function_call variable type">give</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">tree</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">root</span><span class="punctuation_delimiter">,</span> <span class="number">50</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword_exception">try</span> <span class="constant variable_builtin function_call variable type">expect</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin function_call variable type">give</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">root</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">tree</span><span class="punctuation_delimiter">,</span> <span class="number">1</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>   <span class="comment_documentation comment spell">// should fail because we already made tree a parent of root.</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>We write the functions <code>isDescendent</code> and <code>hasParentInAncestry</code> to find out if the requested relation is valid:</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">isDescendant</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">reg</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">Registry</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">ancestor</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">node</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
    <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ancestor</span> <span class="operator">==</span> <span class="constant variable_builtin type variable">node</span><span class="punctuation_bracket">)</span> <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">true</span><span class="punctuation_delimiter">;</span>

    <span class="comment_documentation comment spell">// Check all children of ancestor</span>
    <span class="keyword_repeat">for</span> <span class="punctuation_bracket">(</span><span class="number">0</span><span class="operator">..</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">capacity</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket operator">|</span><span class="constant variable_builtin type variable">child</span><span class="punctuation_bracket operator">|</span> <span class="punctuation_bracket">{</span>
        <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">relations</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">ancestor</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">child</span><span class="punctuation_bracket">]</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="keyword_conditional">if</span> <span class="punctuation_bracket">(</span><span class="constant variable_builtin function_call variable type">isDescendant</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">child</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">node</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
                <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">true</span><span class="punctuation_delimiter">;</span>
            <span class="punctuation_bracket">}</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">false</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">hasParentInAncestry</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">reg</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">Registry</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">potential_parent</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">potential_child</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="type_builtin">bool</span> <span class="punctuation_bracket">{</span>
    <span class="comment_documentation comment spell">// Check if potential_parent is already downstream from potential_child</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin function_call variable type">isDescendant</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">reg</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">potential_child</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin type variable">potential_parent</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>With minimalistic interface in place it is fairly straighforward to create complex model structures. Let’s build up a system of muscle fibers in a flexible way with the above defined graph. We will give all components a position in three dimensions, a cells get a velocity component, and fibers an orientation and tension component. Each fiber consists of 10e5 cells, and we have 42 fibers in total, constituting the muscle tissue:</p><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;build a fiber model&quot;</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">var</span> <span class="constant variable_builtin type variable">arena</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">heap</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">ArenaAllocator</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">testing</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">defer</span> <span class="constant variable_builtin type variable">arena</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">deinit</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">allocator</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">arena</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">allocator</span><span class="punctuation_delimiter">;</span>

    <span class="keyword">var</span> <span class="constant variable_builtin type variable">r</span> <span class="operator">=</span> <span class="keyword_exception">try</span> <span class="constant variable_builtin type variable">Registry</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">init</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">allocator</span><span class="punctuation_delimiter">,</span> <span class="number">100</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

    <span class="keyword">const</span> <span class="constant variable_builtin type variable">x</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">y</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">z</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">position</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">x</span><span class="punctuation_delimiter">,</span> y<span class="punctuation_delimiter">,</span> z<span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="number">1</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">dx</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">dy</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">dz</span> <span class="operator">=</span> <span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">add</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">ComponentType</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">Variable</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">velocity</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">x</span><span class="punctuation_delimiter">,</span> y<span class="punctuation_delimiter">,</span> z<span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="number">1</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

    <span class="keyword">const</span> <span class="constant variable_builtin type variable">cell</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">position</span><span class="punctuation_delimiter">,</span> velocity<span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="number">1</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">fiber</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">position</span><span class="punctuation_delimiter">,</span> cell<span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="number_float">10e5</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">const</span> <span class="constant variable_builtin type variable">muscle</span> <span class="operator">=</span> <span class="constant variable_builtin function_call variable type">assemble</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">r</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">[</span><span class="constant variable_builtin type variable">position</span><span class="punctuation_delimiter">,</span> fiber<span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="number">42</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>We now track all model components using unique IDs (e.g. <code>x</code>, <code>cell</code>, <code>fiber</code>, <code>muscle</code>) which function as flexible building blocks of the model. Now we have an interface for building models in the language of natural hierarchies. The directed acyclic graph holds all information on the relations between components, how many allocations should be made of each component and essentially where one should look to find a particular data point belonging to a specific part of the model.</p><p>We have not allocated any data components yet. In a next article I will describe how allocation can be done with SIMD operations in mind, and implement a <code>view</code> interface to expose the subsets of the data using the graph for specific computations on parts of the data.</p></div>
  <div>
     <!--<h2>Post list</h2>-->
    <div></div>
  </div>

    <footer>
      <hr>
      <h2>find me here:</h2>
      <a class="link" href="krisevers14@gmail.com">email: krisevers14@gmail.com</a>
      <a class="link" href="https://github.com/krisevers">github: github.com/krisevers</a>
      <a class="link" href="https://orcid.org/0000-0002-3386-1259">orcid: https://orcid.org/0000-0002-3386-1259</a>
    </footer>

  </body>
</html>
